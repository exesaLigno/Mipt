{\bfseries{J\+A\+UL}} means $\ast$$\ast$\+J$\ast$$\ast$ust $\ast$$\ast$\+A$\ast$$\ast$nother $\ast$$\ast$\+U$\ast$$\ast$seless $\ast$$\ast$\+L$\ast$$\ast$anguage.\hypertarget{md_README_autotoc_md2}{}\doxysubsection{Contents}\label{md_README_autotoc_md2}

\begin{DoxyItemize}
\item \href{\#jc_usage}{\texttt{ Using -\/ Compiler}} ~\newline

\item \href{\#jvm_usage}{\texttt{ Using -\/ Running J\+VM}} ~\newline

\item \href{\#principle}{\texttt{ Compilation principle}} ~\newline

\item \href{\#object}{\texttt{ Object files}} ~\newline

\item \href{\#jvm}{\texttt{ J\+A\+UL Virtual Mashine}} ~\newline

\item \href{\#assembly}{\texttt{ Assembly}} ~\newline

\item \href{\#examples}{\texttt{ Examples}} ~\newline

\item \href{\#performance}{\texttt{ Performance tests}} ~\newline

\end{DoxyItemize}

\label{_jc_usage}%
\doxysubsection*{Using -\/ \mbox{\hyperlink{classCompiler}{Compiler}}}

{\bfseries{Usage}}\+: {\ttfamily jc \mbox{[}options\mbox{]} file...} ~\newline
 If compiler not installed to {\ttfamily /usr/bin/}, use {\ttfamily ./jc \mbox{[}options\mbox{]} file...}

\mbox{\hyperlink{classCompiler}{Compiler}} supports compilation options\+:


\begin{DoxyItemize}
\item {\ttfamily -\/v} or {\ttfamily -\/-\/verbose} -\/ verbose compilation (by default compiler shows only errors/warnings) ~\newline
 {\ttfamily -\/h} or {\ttfamily -\/-\/help} -\/ show help and exit
\item {\ttfamily -\/p} or {\ttfamily -\/-\/only\+\_\+preprocess} -\/ only preprocess and save preprocessed code to output path ~\newline
 {\ttfamily -\/l} or {\ttfamily -\/-\/nasm\+\_\+listing} -\/ make N\+A\+SM listing it to output path
\item {\ttfamily -\/-\/virtual} -\/ compile code for \href{\#jvm}{\texttt{ J\+VM}} ~\newline
 {\ttfamily -\/-\/obj} -\/ compile code and save it to \href{\#object}{\texttt{ object file}} ~\newline
 If options {\ttfamily -\/p}, {\ttfamily -\/l}, {\ttfamily -\/-\/virtual} or {\ttfamily -\/-\/obj} not given, compiling directly into E\+L\+F-\/64 executable.
\item {\ttfamily -\/o0}, {\ttfamily -\/o1}, {\ttfamily -\/o2} -\/ optimization levels
\item {\ttfamily -\/o $<$filename$>$} -\/ set output file name ~\newline

\end{DoxyItemize}

\mbox{\hyperlink{classCompiler}{Compiler}} takes three file types as input\+:
\begin{DoxyItemize}
\item $\ast$$\ast${\ttfamily .j}$\ast$$\ast$ -\/ simple hi-\/level source (\href{\#examples}{\texttt{ Examples}})
\item $\ast$$\ast${\ttfamily .jo}$\ast$$\ast$ -\/ \href{\#object}{\texttt{ object files}}
\item $\ast$$\ast${\ttfamily .jasm}$\ast$$\ast$ -\/ special J\+A\+UL assembler language (Example of .jasm files at .std folder)
\end{DoxyItemize}

\label{_jvm_usage}%
\doxysubsection*{Using -\/ J\+VM}

Using of \href{\#jvm}{\texttt{ J\+VM}}

\label{_principle}%
\doxysubsection*{Compilation principle}

All source files importing to {\itshape \mbox{\hyperlink{classSource}{Source}}} objects.


\begin{DoxyItemize}
\item {\bfseries{J\+A\+UL \mbox{\hyperlink{classSource}{Source}}}} ~\newline
 First of all, {\itshape \mbox{\hyperlink{classSource}{Source}}} class building {\itshape Abstract Syntax Tree} and by which compiling instructions to {\itshape \mbox{\hyperlink{classBinary}{Binary}}} class object. After that {\itshape \mbox{\hyperlink{classBinary}{Binary}}} object optimizing and calculating local labels, byte code unites function by function (one function in one {\itshape \mbox{\hyperlink{classBinary_1_1Token}{Binary\+::\+Token}}})
\item {\bfseries{J\+A\+UL Object}} ~\newline
 {\itshape \mbox{\hyperlink{classSource}{Source}}} class just keeping byte code of object file, after that transmits it to {\itshape \mbox{\hyperlink{classBinary}{Binary}}} object. It builds object file function by function (one function in one {\itshape \mbox{\hyperlink{classBinary_1_1Token}{Binary\+::\+Token}}}).
\item {\bfseries{J\+A\+UL Assebler Language}} ~\newline
 It works like object files, but building {\itshape \mbox{\hyperlink{classBinary}{Binary}}} object basing on J\+A\+SM code and after that optimizing and calculating local labels like in J\+A\+UL source compilation.
\end{DoxyItemize}

When all {\itshape \mbox{\hyperlink{classBinary}{Binary}}} objects are compiled, optimized and calculated, compiler linking them to one {\itshape \mbox{\hyperlink{classBinary}{Binary}}} object with all functions. If object generation choosen, this {\itshape \mbox{\hyperlink{classBinary}{Binary}}} object just saving in file (\href{\#object}{\texttt{ Object files}}) Else compiler calculating function labels in linked {\itshape \mbox{\hyperlink{classBinary}{Binary}}}, generating E\+L\+F-\/64 (or J\+VM) header and saving all compiled code to executable file.

\label{_object}%
\doxysubsection*{Object files}

Object files contains pre-\/compiled code and functions names for linker.

First 4 bytes is {\ttfamily J\+A\+UL}, next 8 bytes is {\itshape long int} with length of subsequent executable bytecode.

Bytecode contains name of function and bytecode of this function.

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\raggedleft \cellcolor{\tableheadbgcolor}\textbf{ }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Name length }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Name }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Bytes count }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Bytecode  }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\raggedleft \cellcolor{\tableheadbgcolor}\textbf{ }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Name length }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Name }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Bytes count }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Bytecode  }\\\cline{1-5}
\endhead
\PBS\raggedleft Size &\PBS\centering 4 bytes &\PBS\centering ??? &\PBS\centering 8 bytes &\PBS\centering ???  \\\cline{1-5}
\PBS\raggedleft Type &\PBS\centering {\ttfamily int} &\PBS\centering {\ttfamily char$\ast$} &\PBS\centering {\ttfamily long int} &\PBS\centering {\ttfamily char$\ast$}  \\\cline{1-5}
\end{longtabu}


\label{_jvm}%
\doxysubsection*{J\+A\+UL Virtual Mashine}

J\+A\+UL Virtual Mashine

\label{_assembly}%
\doxysubsection*{Assembly}

Compile JC\+: {\ttfamily make jc} ~\newline
 Compile J\+VM\+: {\ttfamily make jvm} ~\newline
 Compile both\+: {\ttfamily make jcp}

If you want to install {\bfseries{J\+A\+UL \mbox{\hyperlink{classCompiler}{Compiler}} Pack}} to {\ttfamily /usr/bin} type {\ttfamily sudo make install}

{\ttfamily make} builds all programms in repository (inlcuding \href{Accessory/ReadBinary}{\texttt{ read\+Binary}}).

{\ttfamily make clean} -\/ Delete all compilation results ~\newline
 {\ttfamily sudo make uninstall} -\/ Uninstall all programms and delete all compilation results

\label{_examples}%
\doxysubsection*{Examples}

Examples of working code you can find in \href{Examples/}{\texttt{ examples}} folder.

\label{_performance}%
\doxysubsection*{Performance tests}